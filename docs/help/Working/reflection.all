<?xml version="1.0" encoding="utf-8"?>
<reflection>
  <assemblies>
    <assembly name="Gemstone.IO">
      <assemblydata version="1.0.7.0" culture="" key="" hash="SHA1" />
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyCompanyAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Grid Protection Alliance</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyConfigurationAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Release</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyCopyrightAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Copyright © 2020</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyDescriptionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>GPA Gemstone IO Library</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyFileVersionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>1.0.7.0</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyInformationalVersionAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>1.0.7 -- Release Build</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyProductAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Gemstone</value>
          </argument>
        </attribute>
        <attribute>
          <type api="T:System.Reflection.AssemblyTitleAttribute" ref="true" />
          <argument>
            <type api="T:System.String" ref="true" />
            <value>Gemstone.IO</value>
          </argument>
        </attribute>
      </attributes>
    </assembly>
  </assemblies>
  <apis>
    <api id="N:Gemstone.IO">
      <apidata name="Gemstone.IO" group="namespace" />
      <elements>
        <element api="T:Gemstone.IO.CachedFileStream" />
        <element api="T:Gemstone.IO.InterprocessCache" />
        <element api="T:Gemstone.IO.SafeFileWatcher" />
      </elements>
    </api>
    <api id="T:Gemstone.IO.CachedFileStream">
      <apidata name="CachedFileStream" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.IO.Stream" ref="true" />
          <type api="T:System.MarshalByRefObject" ref="true" />
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="F:Gemstone.IO.CachedFileStream.DefaultBlockSize" />
        <element api="F:Gemstone.IO.CachedFileStream.DefaultCacheSize" />
        <element api="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode)" />
        <element api="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
        <element api="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
        <element api="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
        <element api="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
        <element api="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
        <element api="M:Gemstone.IO.CachedFileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
        <element api="M:Gemstone.IO.CachedFileStream.Read(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.CachedFileStream.Write(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.CachedFileStream.Flush" />
        <element api="M:Gemstone.IO.CachedFileStream.Flush(System.Boolean)" />
        <element api="M:Gemstone.IO.CachedFileStream.SetLength(System.Int64)" />
        <element api="M:Gemstone.IO.CachedFileStream.Dispose(System.Boolean)" />
        <element api="M:System.IO.Stream.Dispose">
          <apidata name="Dispose" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" final="true" />
          <implements>
            <member api="M:System.IDisposable.Dispose">
              <type api="T:System.IDisposable" ref="true" />
            </member>
          </implements>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="P:Gemstone.IO.CachedFileStream.BlockSize" />
        <element api="P:Gemstone.IO.CachedFileStream.CacheSize" />
        <element api="P:Gemstone.IO.CachedFileStream.CanRead" />
        <element api="P:Gemstone.IO.CachedFileStream.CanWrite" />
        <element api="P:Gemstone.IO.CachedFileStream.CanSeek" />
        <element api="P:Gemstone.IO.CachedFileStream.Position" />
        <element api="P:Gemstone.IO.CachedFileStream.Length" />
        <element api="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <apidata name="BeginRead" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="buffer">
              <arrayOf rank="1">
                <type api="T:System.Byte" ref="false" />
              </arrayOf>
            </parameter>
            <parameter name="offset">
              <type api="T:System.Int32" ref="false" />
            </parameter>
            <parameter name="count">
              <type api="T:System.Int32" ref="false" />
            </parameter>
            <parameter name="callback">
              <type api="T:System.AsyncCallback" ref="true" />
            </parameter>
            <parameter name="state">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.IAsyncResult" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
          <apidata name="BeginWrite" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="buffer">
              <arrayOf rank="1">
                <type api="T:System.Byte" ref="false" />
              </arrayOf>
            </parameter>
            <parameter name="offset">
              <type api="T:System.Int32" ref="false" />
            </parameter>
            <parameter name="count">
              <type api="T:System.Int32" ref="false" />
            </parameter>
            <parameter name="callback">
              <type api="T:System.AsyncCallback" ref="true" />
            </parameter>
            <parameter name="state">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.IAsyncResult" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.Close">
          <apidata name="Close" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.CopyTo(System.IO.Stream)">
          <apidata name="CopyTo" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="destination">
              <type api="T:System.IO.Stream" ref="true" />
            </parameter>
          </parameters>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.CopyTo(System.IO.Stream,System.Int32)">
          <apidata name="CopyTo" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="destination">
              <type api="T:System.IO.Stream" ref="true" />
            </parameter>
            <parameter name="bufferSize">
              <type api="T:System.Int32" ref="false" />
            </parameter>
          </parameters>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.CopyToAsync(System.IO.Stream)">
          <apidata name="CopyToAsync" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="destination">
              <type api="T:System.IO.Stream" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32)">
          <apidata name="CopyToAsync" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="destination">
              <type api="T:System.IO.Stream" ref="true" />
            </parameter>
            <parameter name="bufferSize">
              <type api="T:System.Int32" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
          <apidata name="CopyToAsync" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="destination">
              <type api="T:System.IO.Stream" ref="true" />
            </parameter>
            <parameter name="bufferSize">
              <type api="T:System.Int32" ref="false" />
            </parameter>
            <parameter name="cancellationToken">
              <type api="T:System.Threading.CancellationToken" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.CreateWaitHandle">
          <apidata name="CreateWaitHandle" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Threading.WaitHandle" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
          <attributes>
            <attribute>
              <type api="T:System.ObsoleteAttribute" ref="true" />
              <argument>
                <type api="T:System.String" ref="true" />
                <value>CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.</value>
              </argument>
            </attribute>
          </attributes>
        </element>
        <element api="M:System.IO.Stream.EndRead(System.IAsyncResult)">
          <apidata name="EndRead" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="asyncResult">
              <type api="T:System.IAsyncResult" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.EndWrite(System.IAsyncResult)">
          <apidata name="EndWrite" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="asyncResult">
              <type api="T:System.IAsyncResult" ref="true" />
            </parameter>
          </parameters>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.FlushAsync">
          <apidata name="FlushAsync" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)">
          <apidata name="FlushAsync" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="cancellationToken">
              <type api="T:System.Threading.CancellationToken" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.ObjectInvariant">
          <apidata name="ObjectInvariant" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
          <attributes>
            <attribute>
              <type api="T:System.ObsoleteAttribute" ref="true" />
              <argument>
                <type api="T:System.String" ref="true" />
                <value>Do not call or override this method.</value>
              </argument>
            </attribute>
          </attributes>
        </element>
        <element api="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)">
          <apidata name="ReadAsync" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="buffer">
              <arrayOf rank="1">
                <type api="T:System.Byte" ref="false" />
              </arrayOf>
            </parameter>
            <parameter name="offset">
              <type api="T:System.Int32" ref="false" />
            </parameter>
            <parameter name="count">
              <type api="T:System.Int32" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <type api="T:System.Int32" ref="false" />
              </specialization>
            </type>
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <apidata name="ReadAsync" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="buffer">
              <arrayOf rank="1">
                <type api="T:System.Byte" ref="false" />
              </arrayOf>
            </parameter>
            <parameter name="offset">
              <type api="T:System.Int32" ref="false" />
            </parameter>
            <parameter name="count">
              <type api="T:System.Int32" ref="false" />
            </parameter>
            <parameter name="cancellationToken">
              <type api="T:System.Threading.CancellationToken" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Threading.Tasks.Task`1" ref="true">
              <specialization>
                <type api="T:System.Int32" ref="false" />
              </specialization>
            </type>
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.ReadByte">
          <apidata name="ReadByte" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)">
          <apidata name="WriteAsync" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="buffer">
              <arrayOf rank="1">
                <type api="T:System.Byte" ref="false" />
              </arrayOf>
            </parameter>
            <parameter name="offset">
              <type api="T:System.Int32" ref="false" />
            </parameter>
            <parameter name="count">
              <type api="T:System.Int32" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
          <apidata name="WriteAsync" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="buffer">
              <arrayOf rank="1">
                <type api="T:System.Byte" ref="false" />
              </arrayOf>
            </parameter>
            <parameter name="offset">
              <type api="T:System.Int32" ref="false" />
            </parameter>
            <parameter name="count">
              <type api="T:System.Int32" ref="false" />
            </parameter>
            <parameter name="cancellationToken">
              <type api="T:System.Threading.CancellationToken" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Threading.Tasks.Task" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.IO.Stream.WriteByte(System.Byte)">
          <apidata name="WriteByte" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="value">
              <type api="T:System.Byte" ref="false" />
            </parameter>
          </parameters>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="P:System.IO.Stream.CanTimeout">
          <apidata name="CanTimeout" group="member" subgroup="property" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <propertydata get="true" />
          <getter name="get_CanTimeout" />
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="P:System.IO.Stream.ReadTimeout">
          <apidata name="ReadTimeout" group="member" subgroup="property" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <propertydata get="true" set="true" />
          <getter name="get_ReadTimeout" />
          <setter name="set_ReadTimeout" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="P:System.IO.Stream.WriteTimeout">
          <apidata name="WriteTimeout" group="member" subgroup="property" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <propertydata get="true" set="true" />
          <getter name="get_WriteTimeout" />
          <setter name="set_WriteTimeout" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System.IO" />
            <type api="T:System.IO.Stream" ref="true" />
          </containers>
        </element>
        <element api="M:System.MarshalByRefObject.GetLifetimeService">
          <apidata name="GetLifetimeService" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.MarshalByRefObject" ref="true" />
          </containers>
        </element>
        <element api="M:System.MarshalByRefObject.InitializeLifetimeService">
          <apidata name="InitializeLifetimeService" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.MarshalByRefObject" ref="true" />
          </containers>
        </element>
        <element api="M:System.MarshalByRefObject.MemberwiseClone(System.Boolean)">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <parameters>
            <parameter name="cloneIdentity">
              <type api="T:System.Boolean" ref="false" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.MarshalByRefObject" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.MarshalByRefObject" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Finalize">
          <apidata name="Finalize" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <parameters>
        <parameter name="path">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="mode">
          <type api="T:System.IO.FileMode" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <parameters>
        <parameter name="path">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="mode">
          <type api="T:System.IO.FileMode" ref="false" />
        </parameter>
        <parameter name="access">
          <type api="T:System.IO.FileAccess" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <parameters>
        <parameter name="path">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="mode">
          <type api="T:System.IO.FileMode" ref="false" />
        </parameter>
        <parameter name="access">
          <type api="T:System.IO.FileAccess" ref="false" />
        </parameter>
        <parameter name="share">
          <type api="T:System.IO.FileShare" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <parameters>
        <parameter name="path">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="mode">
          <type api="T:System.IO.FileMode" ref="false" />
        </parameter>
        <parameter name="access">
          <type api="T:System.IO.FileAccess" ref="false" />
        </parameter>
        <parameter name="share">
          <type api="T:System.IO.FileShare" ref="false" />
        </parameter>
        <parameter name="blockSize">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <parameters>
        <parameter name="path">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="mode">
          <type api="T:System.IO.FileMode" ref="false" />
        </parameter>
        <parameter name="access">
          <type api="T:System.IO.FileAccess" ref="false" />
        </parameter>
        <parameter name="share">
          <type api="T:System.IO.FileShare" ref="false" />
        </parameter>
        <parameter name="blockSize">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="useAsync">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <parameters>
        <parameter name="path">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="mode">
          <type api="T:System.IO.FileMode" ref="false" />
        </parameter>
        <parameter name="access">
          <type api="T:System.IO.FileAccess" ref="false" />
        </parameter>
        <parameter name="share">
          <type api="T:System.IO.FileShare" ref="false" />
        </parameter>
        <parameter name="blockSize">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="options">
          <type api="T:System.IO.FileOptions" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.CachedFileStream.BlockSize">
      <apidata name="BlockSize" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_BlockSize" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.CachedFileStream.CacheSize">
      <apidata name="CacheSize" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_CacheSize" />
      <setter name="set_CacheSize" />
      <returns>
        <type api="T:System.Int64" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.CachedFileStream.CanRead">
      <apidata name="CanRead" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="P:System.IO.Stream.CanRead">
          <type api="T:System.IO.Stream" ref="true" />
        </member>
      </overrides>
      <propertydata get="true" />
      <getter name="get_CanRead" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.CachedFileStream.CanSeek">
      <apidata name="CanSeek" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="P:System.IO.Stream.CanSeek">
          <type api="T:System.IO.Stream" ref="true" />
        </member>
      </overrides>
      <propertydata get="true" />
      <getter name="get_CanSeek" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.CachedFileStream.CanWrite">
      <apidata name="CanWrite" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="P:System.IO.Stream.CanWrite">
          <type api="T:System.IO.Stream" ref="true" />
        </member>
      </overrides>
      <propertydata get="true" />
      <getter name="get_CanWrite" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="F:Gemstone.IO.CachedFileStream.DefaultBlockSize">
      <apidata name="DefaultBlockSize" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <value>4096</value>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="F:Gemstone.IO.CachedFileStream.DefaultCacheSize">
      <apidata name="DefaultCacheSize" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Int64" ref="false" />
      </returns>
      <value>262144</value>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.Dispose(System.Boolean)">
      <apidata name="Dispose" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.IO.Stream.Dispose(System.Boolean)">
          <type api="T:System.IO.Stream" ref="true" />
        </member>
      </overrides>
      <parameters>
        <parameter name="disposing">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.Flush">
      <apidata name="Flush" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.IO.Stream.Flush">
          <type api="T:System.IO.Stream" ref="true" />
        </member>
      </overrides>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.Flush(System.Boolean)">
      <apidata name="Flush" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="flushToDisk">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.CachedFileStream.Length">
      <apidata name="Length" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="P:System.IO.Stream.Length">
          <type api="T:System.IO.Stream" ref="true" />
        </member>
      </overrides>
      <propertydata get="true" />
      <getter name="get_Length" />
      <returns>
        <type api="T:System.Int64" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.CachedFileStream.Position">
      <apidata name="Position" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="P:System.IO.Stream.Position">
          <type api="T:System.IO.Stream" ref="true" />
        </member>
      </overrides>
      <propertydata get="true" set="true" />
      <getter name="get_Position" />
      <setter name="set_Position" />
      <returns>
        <type api="T:System.Int64" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.Read(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Read" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)">
          <type api="T:System.IO.Stream" ref="true" />
        </member>
      </overrides>
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="offset">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="count">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <apidata name="Seek" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)">
          <type api="T:System.IO.Stream" ref="true" />
        </member>
      </overrides>
      <parameters>
        <parameter name="offset">
          <type api="T:System.Int64" ref="false" />
        </parameter>
        <parameter name="origin">
          <type api="T:System.IO.SeekOrigin" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Int64" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.SetLength(System.Int64)">
      <apidata name="SetLength" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.IO.Stream.SetLength(System.Int64)">
          <type api="T:System.IO.Stream" ref="true" />
        </member>
      </overrides>
      <parameters>
        <parameter name="value">
          <type api="T:System.Int64" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.CachedFileStream.Write(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Write" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/CachedFileStream.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)">
          <type api="T:System.IO.Stream" ref="true" />
        </member>
      </overrides>
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="offset">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="count">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.CachedFileStream" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.InterprocessCache">
      <apidata name="InterprocessCache" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <implements>
        <type api="T:System.IDisposable" ref="true" />
      </implements>
      <elements>
        <element api="F:Gemstone.IO.InterprocessCache.DefaultMaximumRetryAttempts" />
        <element api="F:Gemstone.IO.InterprocessCache.DefaultRetryDelayInterval" />
        <element api="M:Gemstone.IO.InterprocessCache.#ctor" />
        <element api="M:Gemstone.IO.InterprocessCache.#ctor(System.Int32)" />
        <element api="M:Gemstone.IO.InterprocessCache.Finalize" />
        <element api="M:Gemstone.IO.InterprocessCache.Dispose" />
        <element api="M:Gemstone.IO.InterprocessCache.Dispose(System.Boolean)" />
        <element api="M:Gemstone.IO.InterprocessCache.Save" />
        <element api="M:Gemstone.IO.InterprocessCache.Load" />
        <element api="M:Gemstone.IO.InterprocessCache.WaitForLoad" />
        <element api="M:Gemstone.IO.InterprocessCache.WaitForLoad(System.Int32)" />
        <element api="M:Gemstone.IO.InterprocessCache.WaitForSave" />
        <element api="M:Gemstone.IO.InterprocessCache.WaitForSave(System.Int32)" />
        <element api="M:Gemstone.IO.InterprocessCache.SaveFileData(System.IO.FileStream,System.Byte[])" />
        <element api="M:Gemstone.IO.InterprocessCache.LoadFileData(System.IO.FileStream)" />
        <element api="P:Gemstone.IO.InterprocessCache.FileName" />
        <element api="P:Gemstone.IO.InterprocessCache.FileData" />
        <element api="P:Gemstone.IO.InterprocessCache.AutoSave" />
        <element api="P:Gemstone.IO.InterprocessCache.ReloadOnChange" />
        <element api="P:Gemstone.IO.InterprocessCache.MaximumConcurrentLocks" />
        <element api="P:Gemstone.IO.InterprocessCache.MaximumRetryAttempts" />
        <element api="P:Gemstone.IO.InterprocessCache.RetryDelayInterval" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.#ctor(System.Int32)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <parameters>
        <parameter name="maximumConcurrentLocks">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.InterprocessCache.AutoSave">
      <apidata name="AutoSave" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_AutoSave" />
      <setter name="set_AutoSave" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="F:Gemstone.IO.InterprocessCache.DefaultMaximumRetryAttempts">
      <apidata name="DefaultMaximumRetryAttempts" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <value>5</value>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="F:Gemstone.IO.InterprocessCache.DefaultRetryDelayInterval">
      <apidata name="DefaultRetryDelayInterval" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:System.Double" ref="false" />
      </returns>
      <value>1000</value>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.Dispose">
      <apidata name="Dispose" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:System.IDisposable.Dispose">
          <type api="T:System.IDisposable" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.Dispose(System.Boolean)">
      <apidata name="Dispose" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="true" />
      <parameters>
        <parameter name="disposing">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.InterprocessCache.FileData">
      <apidata name="FileData" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_FileData" />
      <setter name="set_FileData" />
      <returns>
        <arrayOf rank="1">
          <type api="T:System.Byte" ref="false" />
        </arrayOf>
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.InterprocessCache.FileName">
      <apidata name="FileName" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_FileName" />
      <setter name="set_FileName" />
      <returns>
        <type api="T:System.String" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.Finalize">
      <apidata name="Finalize" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.Object.Finalize">
          <type api="T:System.Object" ref="true" />
        </member>
      </overrides>
      <implements>
        <member api="M:System.Object.Finalize">
          <type api="T:System.Object" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.Load">
      <apidata name="Load" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="true" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.LoadFileData(System.IO.FileStream)">
      <apidata name="LoadFileData" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="true" />
      <parameters>
        <parameter name="fileStream">
          <type api="T:System.IO.FileStream" ref="true" />
        </parameter>
      </parameters>
      <returns>
        <arrayOf rank="1">
          <type api="T:System.Byte" ref="false" />
        </arrayOf>
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.InterprocessCache.MaximumConcurrentLocks">
      <apidata name="MaximumConcurrentLocks" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_MaximumConcurrentLocks" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.InterprocessCache.MaximumRetryAttempts">
      <apidata name="MaximumRetryAttempts" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_MaximumRetryAttempts" />
      <setter name="set_MaximumRetryAttempts" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.InterprocessCache.ReloadOnChange">
      <apidata name="ReloadOnChange" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_ReloadOnChange" />
      <setter name="set_ReloadOnChange" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.InterprocessCache.RetryDelayInterval">
      <apidata name="RetryDelayInterval" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_RetryDelayInterval" />
      <setter name="set_RetryDelayInterval" />
      <returns>
        <type api="T:System.Double" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.Save">
      <apidata name="Save" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="true" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.SaveFileData(System.IO.FileStream,System.Byte[])">
      <apidata name="SaveFileData" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="true" />
      <parameters>
        <parameter name="fileStream">
          <type api="T:System.IO.FileStream" ref="true" />
        </parameter>
        <parameter name="fileData">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.WaitForLoad">
      <apidata name="WaitForLoad" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="true" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.WaitForLoad(System.Int32)">
      <apidata name="WaitForLoad" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="true" />
      <parameters>
        <parameter name="millisecondsTimeout">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.WaitForSave">
      <apidata name="WaitForSave" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="true" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.InterprocessCache.WaitForSave(System.Int32)">
      <apidata name="WaitForSave" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/InterprocessCache.cs" />
      <proceduredata virtual="true" />
      <parameters>
        <parameter name="millisecondsTimeout">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.InterprocessCache" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.SafeFileWatcher">
      <apidata name="SafeFileWatcher" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <implements>
        <type api="T:System.IDisposable" ref="true" />
      </implements>
      <elements>
        <element api="M:Gemstone.IO.SafeFileWatcher.#ctor" />
        <element api="M:Gemstone.IO.SafeFileWatcher.#ctor(System.String)" />
        <element api="M:Gemstone.IO.SafeFileWatcher.#ctor(System.String,System.String)" />
        <element api="M:Gemstone.IO.SafeFileWatcher.Finalize" />
        <element api="M:Gemstone.IO.SafeFileWatcher.Dispose" />
        <element api="M:Gemstone.IO.SafeFileWatcher.Dispose(System.Boolean)" />
        <element api="M:Gemstone.IO.SafeFileWatcher.WaitForChanged(System.IO.WatcherChangeTypes)" />
        <element api="M:Gemstone.IO.SafeFileWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)" />
        <element api="M:Gemstone.IO.SafeFileWatcher.BeginInit" />
        <element api="M:Gemstone.IO.SafeFileWatcher.EndInit" />
        <element api="P:Gemstone.IO.SafeFileWatcher.Path" />
        <element api="P:Gemstone.IO.SafeFileWatcher.Filter" />
        <element api="P:Gemstone.IO.SafeFileWatcher.NotifyFilter" />
        <element api="P:Gemstone.IO.SafeFileWatcher.EnableRaisingEvents" />
        <element api="P:Gemstone.IO.SafeFileWatcher.IncludeSubdirectories" />
        <element api="P:Gemstone.IO.SafeFileWatcher.InternalBufferSize" />
        <element api="P:Gemstone.IO.SafeFileWatcher.SynchronizingObject" />
        <element api="P:Gemstone.IO.SafeFileWatcher.Site" />
        <element api="E:Gemstone.IO.SafeFileWatcher.Changed" />
        <element api="E:Gemstone.IO.SafeFileWatcher.Created" />
        <element api="E:Gemstone.IO.SafeFileWatcher.Deleted" />
        <element api="E:Gemstone.IO.SafeFileWatcher.Renamed" />
        <element api="E:Gemstone.IO.SafeFileWatcher.Error" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Security.SecurityCriticalAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.IO.SafeFileWatcher.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.SafeFileWatcher.#ctor(System.String)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <parameters>
        <parameter name="path">
          <type api="T:System.String" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.SafeFileWatcher.#ctor(System.String,System.String)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <parameters>
        <parameter name="path">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="filter">
          <type api="T:System.String" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.SafeFileWatcher.BeginInit">
      <apidata name="BeginInit" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="E:Gemstone.IO.SafeFileWatcher.Changed">
      <apidata name="Changed" group="member" subgroup="event" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <eventdata add="true" remove="true" />
      <adder name="add_Changed" />
      <remover name="remove_Changed" />
      <eventhandler>
        <type api="T:System.IO.FileSystemEventHandler" ref="true" />
      </eventhandler>
      <eventargs>
        <type api="T:System.IO.FileSystemEventArgs" ref="true" />
      </eventargs>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="E:Gemstone.IO.SafeFileWatcher.Created">
      <apidata name="Created" group="member" subgroup="event" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <eventdata add="true" remove="true" />
      <adder name="add_Created" />
      <remover name="remove_Created" />
      <eventhandler>
        <type api="T:System.IO.FileSystemEventHandler" ref="true" />
      </eventhandler>
      <eventargs>
        <type api="T:System.IO.FileSystemEventArgs" ref="true" />
      </eventargs>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="E:Gemstone.IO.SafeFileWatcher.Deleted">
      <apidata name="Deleted" group="member" subgroup="event" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <eventdata add="true" remove="true" />
      <adder name="add_Deleted" />
      <remover name="remove_Deleted" />
      <eventhandler>
        <type api="T:System.IO.FileSystemEventHandler" ref="true" />
      </eventhandler>
      <eventargs>
        <type api="T:System.IO.FileSystemEventArgs" ref="true" />
      </eventargs>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.SafeFileWatcher.Dispose">
      <apidata name="Dispose" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:System.IDisposable.Dispose">
          <type api="T:System.IDisposable" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.SafeFileWatcher.Dispose(System.Boolean)">
      <apidata name="Dispose" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="true" />
      <parameters>
        <parameter name="disposing">
          <type api="T:System.Boolean" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.SafeFileWatcher.EnableRaisingEvents">
      <apidata name="EnableRaisingEvents" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_EnableRaisingEvents" />
      <setter name="set_EnableRaisingEvents" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.SafeFileWatcher.EndInit">
      <apidata name="EndInit" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="E:Gemstone.IO.SafeFileWatcher.Error">
      <apidata name="Error" group="member" subgroup="event" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <eventdata add="true" remove="true" />
      <adder name="add_Error" />
      <remover name="remove_Error" />
      <eventhandler>
        <type api="T:System.IO.ErrorEventHandler" ref="true" />
      </eventhandler>
      <eventargs>
        <type api="T:System.IO.ErrorEventArgs" ref="true" />
      </eventargs>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.SafeFileWatcher.Filter">
      <apidata name="Filter" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_Filter" />
      <setter name="set_Filter" />
      <returns>
        <type api="T:System.String" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.SafeFileWatcher.Finalize">
      <apidata name="Finalize" group="member" subgroup="method" />
      <memberdata visibility="family" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="true" />
      <overrides>
        <member api="M:System.Object.Finalize">
          <type api="T:System.Object" ref="true" />
        </member>
      </overrides>
      <implements>
        <member api="M:System.Object.Finalize">
          <type api="T:System.Object" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.SafeFileWatcher.IncludeSubdirectories">
      <apidata name="IncludeSubdirectories" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_IncludeSubdirectories" />
      <setter name="set_IncludeSubdirectories" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.SafeFileWatcher.InternalBufferSize">
      <apidata name="InternalBufferSize" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_InternalBufferSize" />
      <setter name="set_InternalBufferSize" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.SafeFileWatcher.NotifyFilter">
      <apidata name="NotifyFilter" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_NotifyFilter" />
      <setter name="set_NotifyFilter" />
      <returns>
        <type api="T:System.IO.NotifyFilters" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.SafeFileWatcher.Path">
      <apidata name="Path" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_Path" />
      <setter name="set_Path" />
      <returns>
        <type api="T:System.String" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="E:Gemstone.IO.SafeFileWatcher.Renamed">
      <apidata name="Renamed" group="member" subgroup="event" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <eventdata add="true" remove="true" />
      <adder name="add_Renamed" />
      <remover name="remove_Renamed" />
      <eventhandler>
        <type api="T:System.IO.RenamedEventHandler" ref="true" />
      </eventhandler>
      <eventargs>
        <type api="T:System.IO.RenamedEventArgs" ref="true" />
      </eventargs>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.SafeFileWatcher.Site">
      <apidata name="Site" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_Site" />
      <setter name="set_Site" />
      <returns>
        <type api="T:System.ComponentModel.ISite" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.SafeFileWatcher.SynchronizingObject">
      <apidata name="SynchronizingObject" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_SynchronizingObject" />
      <setter name="set_SynchronizingObject" />
      <returns>
        <type api="T:System.ComponentModel.ISynchronizeInvoke" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.SafeFileWatcher.WaitForChanged(System.IO.WatcherChangeTypes)">
      <apidata name="WaitForChanged" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="changeType">
          <type api="T:System.IO.WatcherChangeTypes" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.IO.WaitForChangedResult" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.SafeFileWatcher.WaitForChanged(System.IO.WatcherChangeTypes,System.Int32)">
      <apidata name="WaitForChanged" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/SafeFileWatcher.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="changeType">
          <type api="T:System.IO.WatcherChangeTypes" ref="false" />
        </parameter>
        <parameter name="timeout">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.IO.WaitForChangedResult" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO" />
        <type api="T:Gemstone.IO.SafeFileWatcher" ref="true" />
      </containers>
    </api>
    <api id="N:Gemstone.IO.Checksums">
      <apidata name="Gemstone.IO.Checksums" group="namespace" />
      <elements>
        <element api="T:Gemstone.IO.Checksums.Adler32" />
        <element api="T:Gemstone.IO.Checksums.ChecksumType" />
        <element api="T:Gemstone.IO.Checksums.Crc16" />
        <element api="T:Gemstone.IO.Checksums.Crc32" />
        <element api="T:Gemstone.IO.Checksums.CrcCCITT" />
        <element api="T:Gemstone.IO.Checksums.Xor16" />
        <element api="T:Gemstone.IO.Checksums.Xor32" />
        <element api="T:Gemstone.IO.Checksums.Xor64" />
        <element api="T:Gemstone.IO.Checksums.Xor8" />
      </elements>
    </api>
    <api id="T:Gemstone.IO.Checksums.Adler32">
      <apidata name="Adler32" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Checksums/Adler32.cs" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.IO.Checksums.Adler32.#ctor" />
        <element api="M:Gemstone.IO.Checksums.Adler32.Reset" />
        <element api="M:Gemstone.IO.Checksums.Adler32.Update(System.Byte)" />
        <element api="M:Gemstone.IO.Checksums.Adler32.Update(System.Byte[])" />
        <element api="M:Gemstone.IO.Checksums.Adler32.Update(System.Byte[],System.Int32,System.Int32)" />
        <element api="P:Gemstone.IO.Checksums.Adler32.Value" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Adler32.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Checksums/Adler32.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Adler32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Adler32.Reset">
      <apidata name="Reset" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Adler32.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Adler32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Adler32.Update(System.Byte)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Adler32.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="value">
          <type api="T:System.Byte" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Adler32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Adler32.Update(System.Byte[])">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Adler32.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Adler32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Adler32.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="offset">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="count">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Adler32" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Checksums.Adler32.Value">
      <apidata name="Value" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Adler32.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_Value" />
      <setter name="set_Value" />
      <returns>
        <type api="T:System.UInt32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Adler32" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.Checksums.ChecksumType">
      <apidata name="ChecksumType" group="type" subgroup="enumeration" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <elements>
        <element api="F:Gemstone.IO.Checksums.ChecksumType.Crc16" />
        <element api="F:Gemstone.IO.Checksums.ChecksumType.ModBus" />
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
      </containers>
    </api>
    <api id="F:Gemstone.IO.Checksums.ChecksumType.Crc16">
      <apidata name="Crc16" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:Gemstone.IO.Checksums.ChecksumType" ref="false" />
      </returns>
      <value>0</value>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.ChecksumType" ref="false" />
      </containers>
    </api>
    <api id="F:Gemstone.IO.Checksums.ChecksumType.ModBus">
      <apidata name="ModBus" group="member" subgroup="field" />
      <memberdata visibility="public" static="true" />
      <fielddata literal="true" initonly="false" serialized="true" />
      <returns>
        <type api="T:Gemstone.IO.Checksums.ChecksumType" ref="false" />
      </returns>
      <value>1</value>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.ChecksumType" ref="false" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.Checksums.Crc16">
      <apidata name="Crc16" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Checksums/Crc16.cs" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.IO.Checksums.Crc16.#ctor" />
        <element api="M:Gemstone.IO.Checksums.Crc16.#ctor(Gemstone.IO.Checksums.ChecksumType)" />
        <element api="M:Gemstone.IO.Checksums.Crc16.Reset" />
        <element api="M:Gemstone.IO.Checksums.Crc16.Reset(Gemstone.IO.Checksums.ChecksumType)" />
        <element api="M:Gemstone.IO.Checksums.Crc16.Update(System.Byte)" />
        <element api="M:Gemstone.IO.Checksums.Crc16.Update(System.Byte[])" />
        <element api="M:Gemstone.IO.Checksums.Crc16.Update(System.Byte[],System.Int32,System.Int32)" />
        <element api="P:Gemstone.IO.Checksums.Crc16.Value" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc16.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Checksums/Crc16.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc16" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc16.#ctor(Gemstone.IO.Checksums.ChecksumType)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Checksums/Crc16.cs" />
      <parameters>
        <parameter name="checksumType">
          <type api="T:Gemstone.IO.Checksums.ChecksumType" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc16" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc16.Reset">
      <apidata name="Reset" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Crc16.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc16" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc16.Reset(Gemstone.IO.Checksums.ChecksumType)">
      <apidata name="Reset" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Crc16.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="checksumType">
          <type api="T:Gemstone.IO.Checksums.ChecksumType" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc16" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc16.Update(System.Byte)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Crc16.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="value">
          <type api="T:System.Byte" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc16" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc16.Update(System.Byte[])">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Crc16.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc16" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc16.Update(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Crc16.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="offset">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="count">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc16" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Checksums.Crc16.Value">
      <apidata name="Value" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Crc16.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_Value" />
      <setter name="set_Value" />
      <returns>
        <type api="T:System.UInt16" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc16" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.Checksums.Crc32">
      <apidata name="Crc32" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Checksums/Crc32.cs" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.IO.Checksums.Crc32.Reset" />
        <element api="M:Gemstone.IO.Checksums.Crc32.Update(System.Int32)" />
        <element api="M:Gemstone.IO.Checksums.Crc32.Update(System.Byte[])" />
        <element api="M:Gemstone.IO.Checksums.Crc32.Update(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.Checksums.Crc32.Compute(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.Checksums.Crc32.#ctor" />
        <element api="P:Gemstone.IO.Checksums.Crc32.Value" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc32.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Checksums/Crc32.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc32.Compute(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Compute" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/Checksums/Crc32.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="offset">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="count">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.UInt32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc32.Reset">
      <apidata name="Reset" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Crc32.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc32.Update(System.Byte[])">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Crc32.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Crc32.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="offset">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="count">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Crc32.Update(System.Int32)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Crc32.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="value">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc32" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Checksums.Crc32.Value">
      <apidata name="Value" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Crc32.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_Value" />
      <setter name="set_Value" />
      <returns>
        <type api="T:System.UInt32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Crc32" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.Checksums.CrcCCITT">
      <apidata name="CrcCCITT" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Checksums/CrcCCITT.cs" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.IO.Checksums.CrcCCITT.#ctor" />
        <element api="M:Gemstone.IO.Checksums.CrcCCITT.Reset" />
        <element api="M:Gemstone.IO.Checksums.CrcCCITT.Update(System.Byte)" />
        <element api="M:Gemstone.IO.Checksums.CrcCCITT.Update(System.Byte[])" />
        <element api="M:Gemstone.IO.Checksums.CrcCCITT.Update(System.Byte[],System.Int32,System.Int32)" />
        <element api="P:Gemstone.IO.Checksums.CrcCCITT.Value" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.CrcCCITT.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Checksums/CrcCCITT.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.CrcCCITT" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.CrcCCITT.Reset">
      <apidata name="Reset" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/CrcCCITT.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.CrcCCITT" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.CrcCCITT.Update(System.Byte)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/CrcCCITT.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="value">
          <type api="T:System.Byte" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.CrcCCITT" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.CrcCCITT.Update(System.Byte[])">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/CrcCCITT.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.CrcCCITT" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.CrcCCITT.Update(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/CrcCCITT.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="offset">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="count">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.CrcCCITT" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Checksums.CrcCCITT.Value">
      <apidata name="Value" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/CrcCCITT.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_Value" />
      <setter name="set_Value" />
      <returns>
        <type api="T:System.UInt16" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.CrcCCITT" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.Checksums.Xor16">
      <apidata name="Xor16" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Checksums/Xor16.cs" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.IO.Checksums.Xor16.#ctor" />
        <element api="M:Gemstone.IO.Checksums.Xor16.Reset" />
        <element api="M:Gemstone.IO.Checksums.Xor16.Update(System.UInt16)" />
        <element api="M:Gemstone.IO.Checksums.Xor16.Update(System.Byte[])" />
        <element api="M:Gemstone.IO.Checksums.Xor16.Update(System.Byte[],System.Int32,System.Int32)" />
        <element api="P:Gemstone.IO.Checksums.Xor16.Value" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor16.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Checksums/Xor16.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor16" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor16.Reset">
      <apidata name="Reset" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor16.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor16" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor16.Update(System.Byte[])">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor16.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor16" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor16.Update(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor16.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="offset">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="count">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor16" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor16.Update(System.UInt16)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor16.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="value">
          <type api="T:System.UInt16" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor16" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Checksums.Xor16.Value">
      <apidata name="Value" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor16.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Value" />
      <returns>
        <type api="T:System.UInt16" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor16" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.Checksums.Xor32">
      <apidata name="Xor32" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Checksums/Xor32.cs" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.IO.Checksums.Xor32.#ctor" />
        <element api="M:Gemstone.IO.Checksums.Xor32.Reset" />
        <element api="M:Gemstone.IO.Checksums.Xor32.Update(System.UInt32)" />
        <element api="M:Gemstone.IO.Checksums.Xor32.Update(System.Byte[])" />
        <element api="M:Gemstone.IO.Checksums.Xor32.Update(System.Byte[],System.Int32,System.Int32)" />
        <element api="P:Gemstone.IO.Checksums.Xor32.Value" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor32.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Checksums/Xor32.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor32.Reset">
      <apidata name="Reset" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor32.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor32.Update(System.Byte[])">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor32.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor32.Update(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor32.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="offset">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="count">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor32" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor32.Update(System.UInt32)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor32.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="value">
          <type api="T:System.UInt32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor32" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Checksums.Xor32.Value">
      <apidata name="Value" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor32.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Value" />
      <returns>
        <type api="T:System.UInt32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor32" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.Checksums.Xor64">
      <apidata name="Xor64" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Checksums/Xor64.cs" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.IO.Checksums.Xor64.#ctor" />
        <element api="M:Gemstone.IO.Checksums.Xor64.Reset" />
        <element api="M:Gemstone.IO.Checksums.Xor64.Update(System.UInt64)" />
        <element api="M:Gemstone.IO.Checksums.Xor64.Update(System.Byte[])" />
        <element api="M:Gemstone.IO.Checksums.Xor64.Update(System.Byte[],System.Int32,System.Int32)" />
        <element api="P:Gemstone.IO.Checksums.Xor64.Value" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor64.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Checksums/Xor64.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor64" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor64.Reset">
      <apidata name="Reset" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor64.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor64" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor64.Update(System.Byte[])">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor64.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor64" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor64.Update(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor64.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="offset">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="count">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor64" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor64.Update(System.UInt64)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor64.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="value">
          <type api="T:System.UInt64" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor64" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Checksums.Xor64.Value">
      <apidata name="Value" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor64.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Value" />
      <returns>
        <type api="T:System.UInt64" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor64" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.Checksums.Xor8">
      <apidata name="Xor8" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Checksums/Xor8.cs" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.IO.Checksums.Xor8.#ctor" />
        <element api="M:Gemstone.IO.Checksums.Xor8.Reset" />
        <element api="M:Gemstone.IO.Checksums.Xor8.Update(System.Byte)" />
        <element api="M:Gemstone.IO.Checksums.Xor8.Update(System.Byte[])" />
        <element api="M:Gemstone.IO.Checksums.Xor8.Update(System.Byte[],System.Int32,System.Int32)" />
        <element api="P:Gemstone.IO.Checksums.Xor8.Value" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor8.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Checksums/Xor8.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor8" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor8.Reset">
      <apidata name="Reset" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor8.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor8" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor8.Update(System.Byte)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor8.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="value">
          <type api="T:System.Byte" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor8" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor8.Update(System.Byte[])">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor8.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor8" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Checksums.Xor8.Update(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Update" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor8.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="buffer">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="offset">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="count">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor8" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Checksums.Xor8.Value">
      <apidata name="Value" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Checksums/Xor8.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_Value" />
      <returns>
        <type api="T:System.Byte" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums" />
        <type api="T:Gemstone.IO.Checksums.Xor8" ref="true" />
      </containers>
    </api>
    <api id="N:Gemstone.IO.Checksums.ChecksumExtensions">
      <apidata name="Gemstone.IO.Checksums.ChecksumExtensions" group="namespace" />
      <elements>
        <element api="T:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions" />
      </elements>
    </api>
    <api id="T:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions">
      <apidata name="ChecksumExtensions" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Checksums/ChecksumExtensions/ChecksumExtensions.cs" />
      <typedata visibility="public" abstract="true" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <elements>
        <element api="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Adler32Checksum(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Crc16Checksum(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.CrcCCITTChecksum(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.ModBusCrcChecksum(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Crc32Checksum(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Xor8Checksum(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Xor16Checksum(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Xor32Checksum(System.Byte[],System.Int32,System.Int32)" />
        <element api="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Xor64Checksum(System.Byte[],System.Int32,System.Int32)" />
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums.ChecksumExtensions" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Adler32Checksum(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Adler32Checksum" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/Checksums/ChecksumExtensions/ChecksumExtensions.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="data">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="startIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="length">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.UInt32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums.ChecksumExtensions" />
        <type api="T:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Crc16Checksum(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Crc16Checksum" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/Checksums/ChecksumExtensions/ChecksumExtensions.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="data">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="startIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="length">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.UInt16" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums.ChecksumExtensions" />
        <type api="T:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Crc32Checksum(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Crc32Checksum" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/Checksums/ChecksumExtensions/ChecksumExtensions.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="data">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="startIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="length">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.UInt32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums.ChecksumExtensions" />
        <type api="T:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.CrcCCITTChecksum(System.Byte[],System.Int32,System.Int32)">
      <apidata name="CrcCCITTChecksum" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/Checksums/ChecksumExtensions/ChecksumExtensions.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="data">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="startIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="length">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.UInt16" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums.ChecksumExtensions" />
        <type api="T:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.ModBusCrcChecksum(System.Byte[],System.Int32,System.Int32)">
      <apidata name="ModBusCrcChecksum" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/Checksums/ChecksumExtensions/ChecksumExtensions.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="data">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="startIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="length">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.UInt16" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums.ChecksumExtensions" />
        <type api="T:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Xor16Checksum(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Xor16Checksum" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/Checksums/ChecksumExtensions/ChecksumExtensions.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="data">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="startIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="length">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.UInt16" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums.ChecksumExtensions" />
        <type api="T:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Xor32Checksum(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Xor32Checksum" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/Checksums/ChecksumExtensions/ChecksumExtensions.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="data">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="startIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="length">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.UInt32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums.ChecksumExtensions" />
        <type api="T:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Xor64Checksum(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Xor64Checksum" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/Checksums/ChecksumExtensions/ChecksumExtensions.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="data">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="startIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="length">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.UInt64" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums.ChecksumExtensions" />
        <type api="T:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="M:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions.Xor8Checksum(System.Byte[],System.Int32,System.Int32)">
      <apidata name="Xor8Checksum" group="member" subgroup="method" />
      <memberdata visibility="public" static="true" />
      <sourceContext file="Gemstone.IO/Checksums/ChecksumExtensions/ChecksumExtensions.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="data">
          <arrayOf rank="1">
            <type api="T:System.Byte" ref="false" />
          </arrayOf>
        </parameter>
        <parameter name="startIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="length">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Byte" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Checksums.ChecksumExtensions" />
        <type api="T:Gemstone.IO.Checksums.ChecksumExtensions.ChecksumExtensions" ref="true" />
      </containers>
      <attributes>
        <attribute>
          <type api="T:System.Runtime.CompilerServices.ExtensionAttribute" ref="true" />
        </attribute>
      </attributes>
    </api>
    <api id="N:Gemstone.IO.Collections">
      <apidata name="Gemstone.IO.Collections" group="namespace" />
      <elements>
        <element api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
        <element api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
        <element api="T:Gemstone.IO.Collections.RollingWindow`1" />
      </elements>
    </api>
    <api id="T:Gemstone.IO.Collections.FileBackedDictionary`2">
      <apidata name="FileBackedDictionary" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <templates>
        <template name="TKey" />
        <template name="TValue" />
      </templates>
      <implements>
        <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
          <specialization>
            <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
          </specialization>
        </type>
        <type api="T:System.Collections.Generic.ICollection`1" ref="true">
          <specialization>
            <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
              <specialization>
                <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              </specialization>
            </type>
          </specialization>
        </type>
        <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
          <specialization>
            <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
              <specialization>
                <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              </specialization>
            </type>
          </specialization>
        </type>
        <type api="T:System.Collections.IEnumerable" ref="true" />
        <type api="T:System.IDisposable" ref="true" />
      </implements>
      <elements>
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.String)" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.String,System.Collections.Generic.IDictionary{`0,`1})" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.String,System.Collections.Generic.IEqualityComparer{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.String,System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.Open" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.OpenRead" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.Add(`0,`1)" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.Remove(`0)" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.ContainsKey(`0)" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.TryGetValue(`0,`1@)" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.Clear" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.GetEnumerator" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.GetKeys" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.GetValues" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.Compact" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.Close" />
        <element api="M:Gemstone.IO.Collections.FileBackedDictionary`2.Dispose" />
        <element api="P:Gemstone.IO.Collections.FileBackedDictionary`2.FilePath" />
        <element api="P:Gemstone.IO.Collections.FileBackedDictionary`2.Count" />
        <element api="P:Gemstone.IO.Collections.FileBackedDictionary`2.IsReadOnly" />
        <element api="P:Gemstone.IO.Collections.FileBackedDictionary`2.DefaultSignature" />
        <element api="P:Gemstone.IO.Collections.FileBackedDictionary`2.Signature" />
        <element api="P:Gemstone.IO.Collections.FileBackedDictionary`2.Item(`0)" />
        <element api="P:Gemstone.IO.Collections.FileBackedDictionary`2.Keys" />
        <element api="P:Gemstone.IO.Collections.FileBackedDictionary`2.Values" />
        <element api="P:Gemstone.IO.Collections.FileBackedDictionary`2.CacheSize" />
        <element api="P:Gemstone.IO.Collections.FileBackedDictionary`2.FragmentationCount" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <parameters>
        <parameter name="dictionary">
          <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <parameters>
        <parameter name="dictionary">
          <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </parameter>
        <parameter name="keyComparer">
          <type api="T:System.Collections.Generic.IEqualityComparer`1" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <parameters>
        <parameter name="keyComparer">
          <type api="T:System.Collections.Generic.IEqualityComparer`1" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.String)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <parameters>
        <parameter name="filePath">
          <type api="T:System.String" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.String,System.Collections.Generic.IDictionary{`0,`1})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <parameters>
        <parameter name="filePath">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="dictionary">
          <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.String,System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <parameters>
        <parameter name="filePath">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="dictionary">
          <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </parameter>
        <parameter name="keyComparer">
          <type api="T:System.Collections.Generic.IEqualityComparer`1" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.#ctor(System.String,System.Collections.Generic.IEqualityComparer{`0})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <parameters>
        <parameter name="filePath">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="keyComparer">
          <type api="T:System.Collections.Generic.IEqualityComparer`1" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.Add(System.Collections.Generic.KeyValuePair{`0,`1})">
      <apidata name="Add" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="item">
          <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.Add(`0)">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
                <specialization>
                  <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                  <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                </specialization>
              </type>
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.Add(`0,`1)">
      <apidata name="Add" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="key">
          <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
        </parameter>
        <parameter name="value">
          <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.IDictionary`2.Add(`0,`1)">
          <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedDictionary`2.CacheSize">
      <apidata name="CacheSize" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_CacheSize" />
      <setter name="set_CacheSize" />
      <returns>
        <type api="T:System.Int64" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.Clear">
      <apidata name="Clear" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.Clear">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
                <specialization>
                  <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                  <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                </specialization>
              </type>
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.Close">
      <apidata name="Close" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.Compact">
      <apidata name="Compact" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
      <apidata name="Contains" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="item">
          <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.Contains(`0)">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
                <specialization>
                  <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                  <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                </specialization>
              </type>
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.ContainsKey(`0)">
      <apidata name="ContainsKey" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="key">
          <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)">
          <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
      <apidata name="CopyTo" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="array">
          <arrayOf rank="1">
            <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
              <specialization>
                <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              </specialization>
            </type>
          </arrayOf>
        </parameter>
        <parameter name="arrayIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
                <specialization>
                  <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                  <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                </specialization>
              </type>
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedDictionary`2.Count">
      <apidata name="Count" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_Count" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <implements>
        <member api="P:System.Collections.Generic.ICollection`1.Count">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
                <specialization>
                  <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                  <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                </specialization>
              </type>
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedDictionary`2.DefaultSignature">
      <apidata name="DefaultSignature" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_DefaultSignature" />
      <returns>
        <arrayOf rank="1">
          <type api="T:System.Byte" ref="false" />
        </arrayOf>
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.Dispose">
      <apidata name="Dispose" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:System.IDisposable.Dispose">
          <type api="T:System.IDisposable" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedDictionary`2.FilePath">
      <apidata name="FilePath" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_FilePath" />
      <setter name="set_FilePath" />
      <returns>
        <type api="T:System.String" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedDictionary`2.FragmentationCount">
      <apidata name="FragmentationCount" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_FragmentationCount" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.GetEnumerator">
      <apidata name="GetEnumerator" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <returns>
        <type api="T:System.Collections.Generic.IEnumerator`1" ref="true">
          <specialization>
            <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
              <specialization>
                <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              </specialization>
            </type>
          </specialization>
        </type>
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
                <specialization>
                  <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                  <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                </specialization>
              </type>
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.GetKeys">
      <apidata name="GetKeys" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="false" />
      <returns>
        <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
          <specialization>
            <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.GetValues">
      <apidata name="GetValues" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="false" />
      <returns>
        <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
          <specialization>
            <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
          </specialization>
        </type>
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedDictionary`2.IsReadOnly">
      <apidata name="IsReadOnly" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_IsReadOnly" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="P:System.Collections.Generic.ICollection`1.IsReadOnly">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
                <specialization>
                  <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                  <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                </specialization>
              </type>
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedDictionary`2.Item(`0)">
      <apidata name="Item" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" set="true" />
      <getter name="get_Item" />
      <setter name="set_Item" />
      <parameters>
        <parameter name="key">
          <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
        </parameter>
      </parameters>
      <returns>
        <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
      </returns>
      <implements>
        <member api="P:System.Collections.Generic.IDictionary`2.Item(`0)">
          <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedDictionary`2.Keys">
      <apidata name="Keys" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_Keys" />
      <returns>
        <type api="T:System.Collections.Generic.ICollection`1" ref="true">
          <specialization>
            <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
          </specialization>
        </type>
      </returns>
      <implements>
        <member api="P:System.Collections.Generic.IDictionary`2.Keys">
          <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.Open">
      <apidata name="Open" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.OpenRead">
      <apidata name="OpenRead" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
      <apidata name="Remove" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="item">
          <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.Remove(`0)">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <type api="T:System.Collections.Generic.KeyValuePair`2" ref="false">
                <specialization>
                  <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                  <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
                </specialization>
              </type>
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.Remove(`0)">
      <apidata name="Remove" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="key">
          <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.IDictionary`2.Remove(`0)">
          <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedDictionary`2.Signature">
      <apidata name="Signature" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_Signature" />
      <setter name="set_Signature" />
      <returns>
        <arrayOf rank="1">
          <type api="T:System.Byte" ref="false" />
        </arrayOf>
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedDictionary`2.TryGetValue(`0,`1@)">
      <apidata name="TryGetValue" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="key">
          <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
        </parameter>
        <parameter name="value" out="true">
          <referenceTo>
            <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
          </referenceTo>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)">
          <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedDictionary`2.Values">
      <apidata name="Values" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedDictionary.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_Values" />
      <returns>
        <type api="T:System.Collections.Generic.ICollection`1" ref="true">
          <specialization>
            <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
          </specialization>
        </type>
      </returns>
      <implements>
        <member api="P:System.Collections.Generic.IDictionary`2.Values">
          <type api="T:System.Collections.Generic.IDictionary`2" ref="true">
            <specialization>
              <template name="TKey" index="0" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
              <template name="TValue" index="1" api="T:Gemstone.IO.Collections.FileBackedDictionary`2" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedDictionary`2" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.Collections.FileBackedHashSet`1">
      <apidata name="FileBackedHashSet" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <typedata visibility="public" sealed="true" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <templates>
        <template name="T" />
      </templates>
      <implements>
        <type api="T:System.Collections.Generic.ISet`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
          </specialization>
        </type>
        <type api="T:System.Collections.Generic.ICollection`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
          </specialization>
        </type>
        <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
          </specialization>
        </type>
        <type api="T:System.Collections.IEnumerable" ref="true" />
        <type api="T:System.IDisposable" ref="true" />
      </implements>
      <elements>
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.String)" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.String,System.Collections.Generic.IEqualityComparer{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.String,System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.String,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.Open" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.OpenRead" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.Add(`0)" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.Remove(`0)" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.RemoveWhere(System.Predicate{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.Contains(`0)" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.Clear" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.CopyTo(`0[],System.Int32)" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.GetEnumerator" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.Compact" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.Close" />
        <element api="M:Gemstone.IO.Collections.FileBackedHashSet`1.Dispose" />
        <element api="P:Gemstone.IO.Collections.FileBackedHashSet`1.FilePath" />
        <element api="P:Gemstone.IO.Collections.FileBackedHashSet`1.Count" />
        <element api="P:Gemstone.IO.Collections.FileBackedHashSet`1.IsReadOnly" />
        <element api="P:Gemstone.IO.Collections.FileBackedHashSet`1.DefaultSignature" />
        <element api="P:Gemstone.IO.Collections.FileBackedHashSet`1.Signature" />
        <element api="P:Gemstone.IO.Collections.FileBackedHashSet`1.CacheSize" />
        <element api="P:Gemstone.IO.Collections.FileBackedHashSet`1.FragmentationCount" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <parameters>
        <parameter name="enumerable">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <parameters>
        <parameter name="enumerable">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="comparer">
          <type api="T:System.Collections.Generic.IEqualityComparer`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <parameters>
        <parameter name="comparer">
          <type api="T:System.Collections.Generic.IEqualityComparer`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.String)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <parameters>
        <parameter name="filePath">
          <type api="T:System.String" ref="true" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.String,System.Collections.Generic.IEnumerable{`0})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <parameters>
        <parameter name="filePath">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="enumerable">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.String,System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <parameters>
        <parameter name="filePath">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="enumerable">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
        <parameter name="comparer">
          <type api="T:System.Collections.Generic.IEqualityComparer`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.#ctor(System.String,System.Collections.Generic.IEqualityComparer{`0})">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <parameters>
        <parameter name="filePath">
          <type api="T:System.String" ref="true" />
        </parameter>
        <parameter name="comparer">
          <type api="T:System.Collections.Generic.IEqualityComparer`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.Add(`0)">
      <apidata name="Add" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="item">
          <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ISet`1.Add(`0)">
          <type api="T:System.Collections.Generic.ISet`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedHashSet`1.CacheSize">
      <apidata name="CacheSize" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_CacheSize" />
      <setter name="set_CacheSize" />
      <returns>
        <type api="T:System.Int64" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.Clear">
      <apidata name="Clear" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.Clear">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.Close">
      <apidata name="Close" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.Compact">
      <apidata name="Compact" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.Contains(`0)">
      <apidata name="Contains" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="item">
          <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.Contains(`0)">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.CopyTo(`0[],System.Int32)">
      <apidata name="CopyTo" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="array">
          <arrayOf rank="1">
            <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
          </arrayOf>
        </parameter>
        <parameter name="arrayIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedHashSet`1.Count">
      <apidata name="Count" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_Count" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <implements>
        <member api="P:System.Collections.Generic.ICollection`1.Count">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedHashSet`1.DefaultSignature">
      <apidata name="DefaultSignature" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_DefaultSignature" />
      <returns>
        <arrayOf rank="1">
          <type api="T:System.Byte" ref="false" />
        </arrayOf>
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.Dispose">
      <apidata name="Dispose" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:System.IDisposable.Dispose">
          <type api="T:System.IDisposable" ref="true" />
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
      <apidata name="ExceptWith" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="other">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <type api="T:System.Collections.Generic.ISet`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedHashSet`1.FilePath">
      <apidata name="FilePath" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_FilePath" />
      <setter name="set_FilePath" />
      <returns>
        <type api="T:System.String" ref="true" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedHashSet`1.FragmentationCount">
      <apidata name="FragmentationCount" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_FragmentationCount" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.GetEnumerator">
      <apidata name="GetEnumerator" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <returns>
        <type api="T:System.Collections.Generic.IEnumerator`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
          </specialization>
        </type>
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
      <apidata name="IntersectWith" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="other">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
          <type api="T:System.Collections.Generic.ISet`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
      <apidata name="IsProperSubsetOf" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="other">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <type api="T:System.Collections.Generic.ISet`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
      <apidata name="IsProperSupersetOf" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="other">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <type api="T:System.Collections.Generic.ISet`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedHashSet`1.IsReadOnly">
      <apidata name="IsReadOnly" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_IsReadOnly" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="P:System.Collections.Generic.ICollection`1.IsReadOnly">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
      <apidata name="IsSubsetOf" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="other">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
          <type api="T:System.Collections.Generic.ISet`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
      <apidata name="IsSupersetOf" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="other">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
          <type api="T:System.Collections.Generic.ISet`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.Open">
      <apidata name="Open" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.OpenRead">
      <apidata name="OpenRead" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="false" />
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
      <apidata name="Overlaps" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="other">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
          <type api="T:System.Collections.Generic.ISet`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.Remove(`0)">
      <apidata name="Remove" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="item">
          <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.Remove(`0)">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.RemoveWhere(System.Predicate{`0})">
      <apidata name="RemoveWhere" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="false" />
      <parameters>
        <parameter name="match">
          <type api="T:System.Predicate`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
      <apidata name="SetEquals" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="other">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
          <type api="T:System.Collections.Generic.ISet`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.FileBackedHashSet`1.Signature">
      <apidata name="Signature" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" set="true" />
      <getter name="get_Signature" />
      <setter name="set_Signature" />
      <returns>
        <arrayOf rank="1">
          <type api="T:System.Byte" ref="false" />
        </arrayOf>
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
      <apidata name="SymmetricExceptWith" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="other">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
          <type api="T:System.Collections.Generic.ISet`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.FileBackedHashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
      <apidata name="UnionWith" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/FileBackedHashSet.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="other">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
          <type api="T:System.Collections.Generic.ISet`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.FileBackedHashSet`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.FileBackedHashSet`1" ref="true" />
      </containers>
    </api>
    <api id="T:Gemstone.IO.Collections.RollingWindow`1">
      <apidata name="RollingWindow" group="type" subgroup="class" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <typedata visibility="public" serializable="false" />
      <family>
        <ancestors>
          <type api="T:System.Object" ref="true" />
        </ancestors>
      </family>
      <templates>
        <template name="T" />
      </templates>
      <implements>
        <type api="T:System.Collections.Generic.IList`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
          </specialization>
        </type>
        <type api="T:System.Collections.Generic.ICollection`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
          </specialization>
        </type>
        <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
          </specialization>
        </type>
        <type api="T:System.Collections.IEnumerable" ref="true" />
      </implements>
      <elements>
        <element api="M:Gemstone.IO.Collections.RollingWindow`1.#ctor(System.Int32)" />
        <element api="M:Gemstone.IO.Collections.RollingWindow`1.Add(`0)" />
        <element api="M:Gemstone.IO.Collections.RollingWindow`1.Insert(System.Int32,`0)" />
        <element api="M:Gemstone.IO.Collections.RollingWindow`1.Remove(`0)" />
        <element api="M:Gemstone.IO.Collections.RollingWindow`1.RemoveAt(System.Int32)" />
        <element api="M:Gemstone.IO.Collections.RollingWindow`1.IndexOf(`0)" />
        <element api="M:Gemstone.IO.Collections.RollingWindow`1.Contains(`0)" />
        <element api="M:Gemstone.IO.Collections.RollingWindow`1.Clear" />
        <element api="M:Gemstone.IO.Collections.RollingWindow`1.CopyTo(`0[],System.Int32)" />
        <element api="M:Gemstone.IO.Collections.RollingWindow`1.GetEnumerator" />
        <element api="P:Gemstone.IO.Collections.RollingWindow`1.Count" />
        <element api="P:Gemstone.IO.Collections.RollingWindow`1.WindowSize" />
        <element api="P:Gemstone.IO.Collections.RollingWindow`1.IsReadOnly" />
        <element api="P:Gemstone.IO.Collections.RollingWindow`1.Item(System.Int32)" />
        <element api="M:System.Object.Equals(System.Object)">
          <apidata name="Equals" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <parameters>
            <parameter name="obj">
              <type api="T:System.Object" ref="true" />
            </parameter>
          </parameters>
          <returns>
            <type api="T:System.Boolean" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.Finalize">
          <apidata name="Finalize" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="true" />
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetHashCode">
          <apidata name="GetHashCode" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.Int32" ref="false" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.GetType">
          <apidata name="GetType" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Type" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.MemberwiseClone">
          <apidata name="MemberwiseClone" group="member" subgroup="method" />
          <memberdata visibility="family" />
          <proceduredata virtual="false" />
          <returns>
            <type api="T:System.Object" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
        <element api="M:System.Object.ToString">
          <apidata name="ToString" group="member" subgroup="method" />
          <memberdata visibility="public" />
          <proceduredata virtual="true" />
          <returns>
            <type api="T:System.String" ref="true" />
          </returns>
          <containers>
            <library assembly="netstandard" module="netstandard" kind="DynamicallyLinkedLibrary" />
            <namespace api="N:System" />
            <type api="T:System.Object" ref="true" />
          </containers>
        </element>
      </elements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.RollingWindow`1.#ctor(System.Int32)">
      <apidata name=".ctor" group="member" subgroup="constructor" />
      <memberdata visibility="public" special="true" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <parameters>
        <parameter name="windowSize">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.RollingWindow`1.Add(`0)">
      <apidata name="Add" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="item">
          <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.Add(`0)">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.RollingWindow`1.Clear">
      <apidata name="Clear" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.Clear">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.RollingWindow`1.Contains(`0)">
      <apidata name="Contains" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="item">
          <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.Contains(`0)">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.RollingWindow`1.CopyTo(`0[],System.Int32)">
      <apidata name="CopyTo" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="array">
          <arrayOf rank="1">
            <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
          </arrayOf>
        </parameter>
        <parameter name="arrayIndex">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.RollingWindow`1.Count">
      <apidata name="Count" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_Count" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <implements>
        <member api="P:System.Collections.Generic.ICollection`1.Count">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.RollingWindow`1.GetEnumerator">
      <apidata name="GetEnumerator" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <returns>
        <type api="T:System.Collections.Generic.IEnumerator`1" ref="true">
          <specialization>
            <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
          </specialization>
        </type>
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.IEnumerable`1.GetEnumerator">
          <type api="T:System.Collections.Generic.IEnumerable`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.RollingWindow`1.IndexOf(`0)">
      <apidata name="IndexOf" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="item">
          <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.IList`1.IndexOf(`0)">
          <type api="T:System.Collections.Generic.IList`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.RollingWindow`1.Insert(System.Int32,`0)">
      <apidata name="Insert" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="index">
          <type api="T:System.Int32" ref="false" />
        </parameter>
        <parameter name="item">
          <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.IList`1.Insert(System.Int32,`0)">
          <type api="T:System.Collections.Generic.IList`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.RollingWindow`1.IsReadOnly">
      <apidata name="IsReadOnly" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" />
      <getter name="get_IsReadOnly" />
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="P:System.Collections.Generic.ICollection`1.IsReadOnly">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.RollingWindow`1.Item(System.Int32)">
      <apidata name="Item" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <propertydata get="true" set="true" />
      <getter name="get_Item" />
      <setter name="set_Item" />
      <parameters>
        <parameter name="index">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <returns>
        <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
      </returns>
      <implements>
        <member api="P:System.Collections.Generic.IList`1.Item(System.Int32)">
          <type api="T:System.Collections.Generic.IList`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.RollingWindow`1.Remove(`0)">
      <apidata name="Remove" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="item">
          <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
        </parameter>
      </parameters>
      <returns>
        <type api="T:System.Boolean" ref="false" />
      </returns>
      <implements>
        <member api="M:System.Collections.Generic.ICollection`1.Remove(`0)">
          <type api="T:System.Collections.Generic.ICollection`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="M:Gemstone.IO.Collections.RollingWindow`1.RemoveAt(System.Int32)">
      <apidata name="RemoveAt" group="member" subgroup="method" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="true" final="true" />
      <parameters>
        <parameter name="index">
          <type api="T:System.Int32" ref="false" />
        </parameter>
      </parameters>
      <implements>
        <member api="M:System.Collections.Generic.IList`1.RemoveAt(System.Int32)">
          <type api="T:System.Collections.Generic.IList`1" ref="true">
            <specialization>
              <template name="T" index="0" api="T:Gemstone.IO.Collections.RollingWindow`1" />
            </specialization>
          </type>
        </member>
      </implements>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
    <api id="P:Gemstone.IO.Collections.RollingWindow`1.WindowSize">
      <apidata name="WindowSize" group="member" subgroup="property" />
      <memberdata visibility="public" />
      <sourceContext file="Gemstone.IO/Collections/RollingWindow.cs" />
      <proceduredata virtual="false" />
      <propertydata get="true" />
      <getter name="get_WindowSize" />
      <returns>
        <type api="T:System.Int32" ref="false" />
      </returns>
      <containers>
        <library assembly="Gemstone.IO" module="Gemstone.IO" kind="DynamicallyLinkedLibrary" />
        <namespace api="N:Gemstone.IO.Collections" />
        <type api="T:Gemstone.IO.Collections.RollingWindow`1" ref="true" />
      </containers>
    </api>
  </apis>
</reflection>